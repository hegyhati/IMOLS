---
title: "GMPL basics"
layout: lecture
lead: "Implementing the (MI)LP models of the motivational examples in GMPL."
id: gmplbasics
prerequisite: ["lpfirststeps"]
---

<h2>(MI)LP description languages and solvers</h2>

<p>
  Since MILP and LP models are widely used in practice, the algorithms solving them are well implemented already.
  Thus, there is no need to implement the simplex algorithm ourselves.
  Thruthfully, it is better if one doesn't do that unless it is for getting a bit of coding practice.
  State-of-the-art solvers are rather complex, and there are small but significant details (like floating point rounding), that have to be addressed to produce a stable solver, and even if that is done, the result will be nowhere close to the efficiency of the solvers mentioned below.
  The solvers in the list use a lot of theoretical accelerations (e.g. <a href="https://en.wikipedia.org/wiki/LU_decomposition" target="_blank">LU decomposition</a>), implementational "tricks" (e.g. <a href="https://en.wikipedia.org/wiki/Sparse_matrix" target="_blank">Sparse representation</a>), and a lots of heuristic accelerations.
</p>

<p>
  There are several choices for solving MILP/LP problems.
  Some are listed below, with some information about them.
</p>

<table class="table table-hover">
  <thead>
    <tr>
      <th scope="col">Solver</th>
      <th scope="col">License</th>
      <th scope="col">Problem classes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row"><a href="http://lpsolve.sourceforge.net/5.5/Intro.htm" target="_blank">lp_solve</a></td>
      <td><a href="https://opensource.org/licenses/lgpl-license" target="_blank">LGPL</a></td>
      <td>MILP</td>
    </tr>
    <tr>
      <td scope="row"><a href="https://www.gnu.org/software/glpk/" target="_blank">GLPK</a></td>
      <td><a href="https://opensource.org/licenses/gpl-license" target="_blank">GPL</a></td>
      <td>MILP</td>
    </tr>
    <tr>
      <td scope="row"><a href="https://projects.coin-or.org/Clp" target="_blank">COIN-OR CLP</a></td>
      <td><a href="https://opensource.org/licenses/EPL-1.0" target="_blank">EPL</a></td>
      <td>LP</td>
    </tr>
    <tr>
      <td scope="row"><a href="https://projects.coin-or.org/Cbc" target="_blank">COIN-OR CBC</a></td>
      <td><a href="https://opensource.org/licenses/EPL-1.0" target="_blank">EPL</a></td>
      <td>MILP</td>
    </tr>
    <tr>
      <td scope="row"><a href="https://gurobi.com" target="_blank">Gurobi</a></td>
      <td>Proprietary - Gurobi Optimization</td>
      <td>MIQP <span class="badge badge-info" data-toggle="popover" title="Mixed-Integer Quadratically Constrained Programming" data-content="The constraints and the objective function may have quadratic terms.">i</span></li></td>
    </tr>
    <tr>
      <td scope="row"><a href="https://gurobi.com" target="_blank">CPLEX</a></td>
      <td>Proprietary - IBM</td>
      <td>MIQP <span class="badge badge-info" data-toggle="popover" title="Mixed-Integer Quadratically Constrained Programming" data-content="The constraints and the objective function may have quadratic terms.">i</span></li></td>
    </tr>
  </tbody>
</table>

<p>
  As this selective list shows, there are a lot of options to chose from, and <a href="https://en.wikipedia.org/wiki/List_of_optimization_software" target="_blank">there is even more</a>.  
</p>

<p>
  Regarding performance, the proprietary tools outperform the open source alternatives by far.
  Among the open source solutions, the COIN OR project can be considered the fastest one.
  Ultimately, the situation dictates, which one you should apply.
  For example, I use (or would use)
  <ul>
    <li>the standalone solver of GLPK for teaching purposes, as it is really simple to install/use, and it is freely available.</li>
    <li>the API of COIN OR in scientific software, that need to solve MILP problems as subproblems.</li>
    <li>Gurobi/CPLEX and COIN OR CBC for comparison purposes in scientific papers.</li>
    <li>Gurobi/CPLEX in an industrial environment where efficiency is key.</li>
  </ul>
  These are of course only my recommendations, and each situation is different.
  Note, that there are academic licenses for the proprietary tools as well.
</p>

<p>
  If the solver is selected, you can either use its API from your code, or use the standalone solver with a model file.
  Different tools support API for different languages, but let us focus on the second option for now.
  There is a wide variety of languages for describing MILP models, and the tools usually support several of them.
  The table below shows some examples.
</p>


<table class="table table-hover">
  <thead>
    <tr>
      <th scope="col">Format name</th>
      <th scope="col">Usual extension</th>
      <th scope="col">Description, notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row"><a href="https://en.wikipedia.org/wiki/AMPL" target="_blank">AMPL</a></td>
      <td><code>.mod .dat .run</code></td>
      <td>A Mathematical Programming Language. Very general and multipurpose language, widely used.</td>
    </tr>
    <tr>
      <td scope="row"><a href="https://en.wikibooks.org/wiki/GLPK/GMPL_(MathProg)" target="_blank">GMPL</a></td>
      <td><code>.mod .dat</code></td>
      <td>GNU Mathematical Programming Language. Subset of AMPL, default for glpk.</td>
    </tr>
    <tr>
      <td scope="row"><a href="https://en.wikibooks.org/wiki/GLPK/GMPL_(MathProg)" target="_blank">MPS</a></td>
      <td><code>.mod .dat</code></td>
      <td>Mathematical Programming System. Old format, most solvers can use it as a legacy option.</td>
    </tr>
    <tr>
      <td scope="row"><a href="https://en.wikipedia.org/wiki/General_Algebraic_Modeling_System" target="_blank">GAMS</a></td>
      <td><code>TODO</code></td>
      <td>General Algebraic Modeling System. A file format, an interpreter, an IDE and an API for solvers.</td>
    </tr>    
    <tr>
      <td scope="row"><a href="http://lpsolve.sourceforge.net/5.0/CPLEX-format.htm" target="_blank">CPLEX</a></td>
      <td><code>.lp</code></td>
      <td>Default format for CPLEX, widely accepted by other solvers.</td>
    </tr>
  </tbody>
</table>

<p>
  Below You can see the same example in a few different formats for comapirson.
</p>

<ul class="nav nav-tabs" id="fortmatTab" role="tablist">
  <li class="nav-item">
    <a class="nav-link active" id="home-tab" data-toggle="tab" href="#mathematic" role="tab" aria-controls="mathematic" aria-selected="true">Mathematical Model</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" id="mps-tab" data-toggle="tab" href="#mps" role="tab" aria-controls="mps" aria-selected="false">MPS (fixed)</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" id="mps2-tab" data-toggle="tab" href="#mps2" role="tab" aria-controls="mps2" aria-selected="false">MPS (free)</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" id="clp-tab" data-toggle="tab" href="#clp" role="tab" aria-controls="clp" aria-selected="false">CPLEX</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" id="gmpl-tab" data-toggle="tab" href="#gmpl" role="tab" aria-controls="gmpl" aria-selected="false">GMPL</a>
  </li>
</ul>
<div class="tab-content b-2" id="myTabContent">
  <div class="tab-pane fade show active" id="mathematic" role="tabpanel" aria-labelledby="mathematic-tab">
      \[x,y \in [0,\infty[ \]
      <br>
      \[x+2\cdot y\le 15\]
      \[3\cdot x+y\le 20\]
      <hr />
      \[x+y \to max\]
  </div>
  <div class="tab-pane fade" id="mps" role="tabpanel" aria-labelledby="mps-tab">
    <pre><code>{% include sources/helloworld/helloworld_fix.mps %}</code></pre>
  </div>
  <div class="tab-pane fade" id="mps2" role="tabpanel" aria-labelledby="mps2-tab">
    <pre><code>{% include sources/helloworld/helloworld_free.mps %}</code></pre>
  </div>
  <div class="tab-pane fade" id="clp" role="tabpanel" aria-labelledby="clp-tab">
    <pre><code>{% include sources/helloworld/helloworld.lp %}</code></pre>
  </div>
  <div class="tab-pane fade" id="gmpl" role="tabpanel" aria-labelledby="gmpl-tab">
    <pre><code>{% include sources/helloworld/helloworld.m %}</code></pre>
  </div>
</div>

<div class="alert alert-primary">
  On this site, we will use the <b>GMPL</b> file format, and the <b>glpsol</b> solver to solve our problems.
  Please note, that if you need Your model in a different format, You can also use glpsol to convert it with the <code>--wmps</code>, <code>--wfreemps</code>, <code>--wlp</code> options.
</div>

<h2>GMPL basics</h2>

<p>
  As it was discussed <a href="{{site.baseurl}}/pages/lpfirststeps.html">previously</a>, the model can be partitioned into three parts: variable declarations, constraints, and the objective function.
  We will follow this order to introduce the basic syntactic elements of GMPL.
  You can find a detailed <a href="https://www.gnu.org/software/glpk/#documentation" target="_blank">reference of the GMPL format</a> if You download the package from the website of glpk.
</p>

<h3>Variables</h3>

<p>
  Variables can be defined with the <code>var</code> keyword, that should be followed by the name of the variable, restrictions on the domain, and finally a semicolon.
  Some examples:
</p>

<table class="table table-hover">
  <thead>
    <tr>
      <th scope="col">Mathematical notation</th>
      <th scope="col">GMPL description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>\(x\in[0,\infty[\)</td>
      <td><code>var x>=0;</code></td>
    </tr>    
    <tr>
      <td>\(x\in[0,8]\)</td>
      <td><code>var x>=0,<=8;</code></td>
    </tr>  
    <tr>
      <td>\(y\in\{0,1\}\)</td>
      <td><code>var y binary;</code></td>
    </tr>
    <tr>
      <td>\(y\in\mathbb{Z}\)</td>
      <td><code>var y integer;</code></td>
    </tr>
    <tr>
      <td>\(y\in\mathbb{N}\)</td>
      <td><code>var y integer >=0;</code></td>
    </tr>
  </tbody>
</table>

<hr />

<div class="alert alert-dark">
  
<h1 class="alert-heading">Final notes</h1>



</div>
